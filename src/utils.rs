use bevy::ecs::*;

// Add std to the doc generated by cargo doc
#[doc(inline)]
pub use std;

#[allow(dead_code)]
pub fn count_query_filter<Q: WorldQuery, F: QueryFilter>(mut query: Query<Q, F>) {
    let name = std::any::type_name::<Q>();
    println!("{}: {}", name, query.iter_mut().count());
}

#[allow(dead_code, unused_mut)]
pub fn count_query<Q: WorldQuery>(mut query: Query<Q>) {
    count_query_filter::<Q, ()>(query);
}

#[cfg(test)]
pub mod tests {
    use bevy::app::*;
    use bevy::prelude::*;
    use bevy::winit::*;
    use serial_test::serial;

    #[test]
    #[serial]
    fn empty_test_app_with_frames() {
        App::build()
            .add_plugin(Test::Frames(5))
            .run();
    }

    #[test]
    #[serial]
    fn empty_test_app_with_times() {
        App::build()
            .add_plugin(Test::Time(0.5))
            .run();
    }

    #[derive(Clone)]
    pub enum Test {
        Frames(i32),
        Time(f32),
    }

    impl Test {
        fn system(&self) -> impl System<In = (), Out = ()> {
            match self.clone() {
                Self::Frames(count) => (move |c, e| Self::frames(count, c, e)).system(),
                Self::Time(time) => (move |c, t, e| Self::times(time, c, t, e)).system(),
            }
        }

        fn frames(max: i32, mut current: Local<i32>, mut exit: ResMut<Events<AppExit>>) {
            *current += 1;
            if max <= *current {
                exit.send(AppExit);
            }
        }

        fn times(end_time: f32, mut current_time: Local<f32>, time: Res<Time>, mut exit: ResMut<Events<AppExit>>) {
            *current_time += time.delta_seconds();
            if end_time <= *current_time {
                exit.send(AppExit);
            }
        }
    }

    impl Plugin for Test {
        fn build(&self, app: &mut AppBuilder) {
            app.add_plugins(NoLogPlugins);
            app.set_runner(winit_runner_any_thread);
            app.add_resource(WinitConfig { return_from_run: true, });
            app.add_system_to_stage(stage::POST_UPDATE, self.system());
        }
    }

    struct NoLogPlugins;
    impl PluginGroup for NoLogPlugins {
        fn build(&mut self, group: &mut PluginGroupBuilder) {
            group.add(bevy::reflect::ReflectPlugin::default());
            group.add(bevy::core::CorePlugin::default());
            group.add(bevy::transform::TransformPlugin::default());
            group.add(bevy::diagnostic::DiagnosticsPlugin::default());
            group.add(bevy::input::InputPlugin::default());
            group.add(bevy::window::WindowPlugin::default());
            group.add(bevy::asset::AssetPlugin::default());
            group.add(bevy::scene::ScenePlugin::default());
            group.add(bevy::render::RenderPlugin::default());
            group.add(bevy::sprite::SpritePlugin::default());
            group.add(bevy::pbr::PbrPlugin::default());
            group.add(bevy::ui::UiPlugin::default());
            group.add(bevy::text::TextPlugin::default());
            group.add(bevy::audio::AudioPlugin::default());
            group.add(bevy::gltf::GltfPlugin::default());
            group.add(bevy::winit::WinitPlugin::default());
            group.add(bevy::wgpu::WgpuPlugin::default());
        }
    }
}
